[{"C:\\Users\\Yehia\\Desktop\\Work\\uni\\Micro\\microgui\\Micro-GUI\\src\\index.js":"1","C:\\Users\\Yehia\\Desktop\\Work\\uni\\Micro\\microgui\\Micro-GUI\\src\\reportWebVitals.js":"2","C:\\Users\\Yehia\\Desktop\\Work\\uni\\Micro\\microgui\\Micro-GUI\\src\\App.js":"3","C:\\Users\\Yehia\\Desktop\\Work\\uni\\Micro\\microgui\\Micro-GUI\\src\\Cycle.js":"4","C:\\Users\\Yehia\\Desktop\\Work\\uni\\Micro\\microgui\\Micro-GUI\\src\\Helpers.js":"5"},{"size":517,"mtime":1610631325175,"results":"6","hashOfConfig":"7"},{"size":375,"mtime":1610631325176,"results":"8","hashOfConfig":"7"},{"size":14326,"mtime":1610659813244,"results":"9","hashOfConfig":"7"},{"size":5078,"mtime":1610658267726,"results":"10","hashOfConfig":"7"},{"size":14672,"mtime":1610655659451,"results":"11","hashOfConfig":"7"},{"filePath":"12","messages":"13","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"14"},"bupjbb",{"filePath":"15","messages":"16","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"14"},{"filePath":"17","messages":"18","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"19","messages":"20","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"21","messages":"22","errorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"23","usedDeprecatedRules":"14"},"C:\\Users\\Yehia\\Desktop\\Work\\uni\\Micro\\microgui\\Micro-GUI\\src\\index.js",[],["24","25"],"C:\\Users\\Yehia\\Desktop\\Work\\uni\\Micro\\microgui\\Micro-GUI\\src\\reportWebVitals.js",[],"C:\\Users\\Yehia\\Desktop\\Work\\uni\\Micro\\microgui\\Micro-GUI\\src\\App.js",[],"C:\\Users\\Yehia\\Desktop\\Work\\uni\\Micro\\microgui\\Micro-GUI\\src\\Cycle.js",[],"C:\\Users\\Yehia\\Desktop\\Work\\uni\\Micro\\microgui\\Micro-GUI\\src\\Helpers.js",["26","27","28","29","30"],"var instructionQueue = []\r\nvar finish = false\r\nvar writeQueue = []\r\nvar loadBuffer = [\r\n  { name: 'L1', busy: 0, address: 0, index: -1 },\r\n  { name: 'L2', busy: 0, address: 0, index: -1 },\r\n]\r\nvar storeBuffer = [\r\n  { name: 'S1', busy: 0, address: 0, V: '', Q: '', index: -1 },\r\n  { name: 'S2', busy: 0, address: 0, V: '', Q: '', index: -1 },\r\n]\r\nvar addSubRS = [\r\n  { name: 'A1', op: '', Vj: '', Vk: '', Qj: '', Qk: '', busy: 0, index: -1 },\r\n  { name: 'A2', op: '', Vj: '', Vk: '', Qj: '', Qk: '', busy: 0, index: -1 },\r\n  { name: 'A3', op: '', Vj: '', Vk: '', Qj: '', Qk: '', busy: 0, index: -1 },\r\n]\r\nvar mulDivRS = [\r\n  { name: 'M1', op: '', Vj: '', Vk: '', Qj: '', Qk: '', busy: 0, index: -1 },\r\n  { name: 'M2', op: '', Vj: '', Vk: '', Qj: '', Qk: '', busy: 0, index: -1 },\r\n]\r\nvar intRegFile = [\r\n  { name: 'R1', val: 0 },\r\n  { name: 'R2', val: 4 },\r\n]\r\nvar regFile = [\r\n  { reg: 'F0', Q: 0 },\r\n  { reg: 'F1', Q: 0 },\r\n  { reg: 'F2', Q: 0 },\r\n  { reg: 'F3', Q: 0 },\r\n  { reg: 'F4', Q: 0 },\r\n  { reg: 'F5', Q: 0 },\r\n  { reg: 'F6', Q: 0 },\r\n  { reg: 'F7', Q: 0 },\r\n  { reg: 'F8', Q: 0 },\r\n  { reg: 'F9', Q: 0 },\r\n  { reg: 'F10', Q: 0 },\r\n]\r\nvar dataMemory = [\r\n  23,\r\n  3,\r\n  9,\r\n  34,\r\n  434,\r\n  8,\r\n  2,\r\n  24,\r\n  23,\r\n  4,\r\n  23,\r\n  3,\r\n  9,\r\n  34,\r\n  434,\r\n  8,\r\n  2,\r\n  24,\r\n  23,\r\n  4,\r\n  23,\r\n  3,\r\n  9,\r\n  34,\r\n  434,\r\n  8,\r\n  2,\r\n  24,\r\n  23,\r\n  4,\r\n  1,\r\n  2,\r\n]\r\nvar counter = 0\r\nvar cycle = 1\r\nlet addCycles = 4\r\nlet subCycles = 4\r\nlet mulCycles = 6\r\nlet divCycles = 10\r\nlet loadCycles = 2\r\nlet storeCycles = 2\r\n\r\n// const addCycles = 2;\r\n// const mulCycles = 10;\r\n// const divCycles = 40;\r\n// const loadCycles = 2;\r\n\r\nconst addToQueue = (instruction) => {\r\n  instructionQueue.push(instruction)\r\n}\r\nconst issueLoad = () => {\r\n  if (loadBuffer[0].busy === 0 || loadBuffer[1].busy === 0) {\r\n    let found = false\r\n    for (let i = 0; i < storeBuffer.length; i++) {\r\n      if (\r\n        storeBuffer[i].address ===\r\n        instructionQueue[counter].J / 4 +\r\n          intRegFile.find((one) => one.name === instructionQueue[counter].K).val\r\n      ) {\r\n        found = true\r\n        break\r\n      }\r\n    }\r\n    if (!found) {\r\n      const index = loadBuffer[0].busy === 0 ? 0 : 1\r\n      loadBuffer[index].busy = 1\r\n      loadBuffer[index].address =\r\n        instructionQueue[counter].J / 4 +\r\n        intRegFile.find((one) => one.name === instructionQueue[counter].K).val\r\n      loadBuffer[index].index = counter\r\n      regFile.find((one) => one.reg === instructionQueue[counter].D).Q =\r\n        loadBuffer[index].name\r\n      instructionQueue[counter].issue = cycle\r\n      counter++\r\n    }\r\n  }\r\n}\r\nconst issueStore = () => {\r\n  if (storeBuffer[0].busy === 0 || storeBuffer[1].busy === 0) {\r\n    let found = false\r\n    for (let i = 0; i < storeBuffer.length; i++) {\r\n      if (\r\n        storeBuffer[i].address ===\r\n          instructionQueue[counter].J / 4 +\r\n            intRegFile.find((one) => one.name === instructionQueue[counter].K)\r\n              .val ||\r\n        loadBuffer[i].address ===\r\n          instructionQueue[counter].J / 4 +\r\n            intRegFile.find((one) => one.name === instructionQueue[counter].K)\r\n              .val\r\n      ) {\r\n        found = true\r\n        break\r\n      }\r\n    }\r\n    if (!found) {\r\n      const index = storeBuffer[0].busy === 0 ? 0 : 1\r\n      storeBuffer[index].busy = 1\r\n      storeBuffer[index].address =\r\n        instructionQueue[counter].J / 4 +\r\n        intRegFile.find((one) => one.name === instructionQueue[counter].K).val\r\n      instructionQueue[counter].issue = cycle\r\n      storeBuffer[index].index = counter\r\n      const reg = regFile.find((one) => one.reg === instructionQueue[counter].D)\r\n      typeof reg.Q === 'number'\r\n        ? (storeBuffer[index].v = reg.Q)\r\n        : (storeBuffer[index].Q = reg.Q)\r\n      counter++\r\n    }\r\n  }\r\n}\r\nconst issueAdd = () => {\r\n  if (\r\n    addSubRS[0].busy === 0 ||\r\n    addSubRS[1].busy === 0 ||\r\n    addSubRS[2].busy === 0\r\n  ) {\r\n    const index = addSubRS[0].busy === 0 ? 0 : addSubRS[1].busy === 0 ? 1 : 2\r\n    addSubRS[index].busy = 1\r\n    addSubRS[index].op = 'ADD'\r\n    const regJ = regFile.find((one) => one.reg === instructionQueue[counter].J)\r\n    const regK = regFile.find((one) => one.reg === instructionQueue[counter].K)\r\n    typeof regJ.Q === 'number'\r\n      ? (addSubRS[index].Vj = regJ.Q)\r\n      : (addSubRS[index].Qj = regJ.Q)\r\n    typeof regK.Q === 'number'\r\n      ? (addSubRS[index].Vk = regK.Q)\r\n      : (addSubRS[index].Qk = regK.Q)\r\n    regFile.find((one) => one.reg === instructionQueue[counter].D).Q =\r\n      addSubRS[index].name\r\n    addSubRS[index].index = counter\r\n    instructionQueue[counter].issue = cycle\r\n    counter++\r\n  }\r\n}\r\nconst issueSub = () => {\r\n  console.log('instruction queue', instructionQueue[counter])\r\n  console.log('reg file:', regFile)\r\n  if (\r\n    addSubRS[0].busy === 0 ||\r\n    addSubRS[1].busy === 0 ||\r\n    addSubRS[2].busy === 0\r\n  ) {\r\n    const index = addSubRS[0].busy === 0 ? 0 : addSubRS[1].busy === 0 ? 1 : 2\r\n    addSubRS[index].busy = 1\r\n    addSubRS[index].op = 'SUB'\r\n    const regJ = regFile.find((one) => one.reg === instructionQueue[counter].J)\r\n    const regK = regFile.find((one) => one.reg === instructionQueue[counter].K)\r\n    console.log('counter:', counter)\r\n    typeof regJ.Q === 'number'\r\n      ? (addSubRS[index].Vj = regJ.Q)\r\n      : (addSubRS[index].Qj = regJ.Q)\r\n    typeof regK.Q === 'number'\r\n      ? (addSubRS[index].Vk = regK.Q)\r\n      : (addSubRS[index].Qk = regK.Q)\r\n    regFile.find((one) => one.reg === instructionQueue[counter].D).Q =\r\n      addSubRS[index].name\r\n    addSubRS[index].index = counter\r\n    instructionQueue[counter].issue = cycle\r\n    counter++\r\n  }\r\n}\r\nconst issueMul = () => {\r\n  if (mulDivRS[0].busy === 0 || mulDivRS[1].busy === 0) {\r\n    const index = mulDivRS[0].busy === 0 ? 0 : 1\r\n    mulDivRS[index].busy = 1\r\n    mulDivRS[index].op = 'MUL'\r\n    const regJ = regFile.find((one) => one.reg === instructionQueue[counter].J)\r\n    const regK = regFile.find((one) => one.reg === instructionQueue[counter].K)\r\n    typeof regJ.Q === 'number'\r\n      ? (mulDivRS[index].Vj = regJ.Q)\r\n      : (mulDivRS[index].Qj = regJ.Q)\r\n    typeof regK.Q === 'number'\r\n      ? (mulDivRS[index].Vk = regK.Q)\r\n      : (mulDivRS[index].Qk = regK.Q)\r\n    regFile.find((one) => one.reg === instructionQueue[counter].D).Q =\r\n      mulDivRS[index].name\r\n    mulDivRS[index].index = counter\r\n    instructionQueue[counter].issue = cycle\r\n    counter++\r\n  }\r\n}\r\nconst issueDiv = () => {\r\n  if (mulDivRS[0].busy === 0 || mulDivRS[1].busy === 0) {\r\n    const index = mulDivRS[0].busy === 0 ? 0 : 1\r\n    mulDivRS[index].busy = 1\r\n    mulDivRS[index].op = 'DIV'\r\n    const regJ = regFile.find((one) => one.reg === instructionQueue[counter].J)\r\n    const regK = regFile.find((one) => one.reg === instructionQueue[counter].K)\r\n    typeof regJ.Q === 'number'\r\n      ? (mulDivRS[index].Vj = regJ.Q)\r\n      : (mulDivRS[index].Qj = regJ.Q)\r\n    typeof regK.Q === 'number'\r\n      ? (mulDivRS[index].Vk = regK.Q)\r\n      : (mulDivRS[index].Qk = regK.Q)\r\n    regFile.find((one) => one.reg === instructionQueue[counter].D).Q =\r\n      mulDivRS[index].name\r\n    mulDivRS[index].index = counter\r\n    instructionQueue[counter].issue = cycle\r\n    counter++\r\n  }\r\n}\r\nconst distribute = (pass) => {\r\n  for (let i = 0; i < addSubRS.length; i++) {\r\n    if (addSubRS[i].Qj === pass.name) {\r\n      addSubRS[i].Qj = ''\r\n      addSubRS[i].Vj = pass.value\r\n    }\r\n    if (addSubRS[i].Qk === pass.name) {\r\n      addSubRS[i].Qk = ''\r\n      addSubRS[i].Vk = pass.value\r\n    }\r\n  }\r\n  for (let i = 0; i < mulDivRS.length; i++) {\r\n    if (mulDivRS[i].Qj === pass.name) {\r\n      mulDivRS[i].Qj = ''\r\n      mulDivRS[i].Vj = pass.value\r\n    }\r\n    if (mulDivRS[i].Qk === pass.name) {\r\n      mulDivRS[i].Qk = ''\r\n      mulDivRS[i].Vk = pass.value\r\n    }\r\n  }\r\n  for (let i = 0; i < storeBuffer.length; i++) {\r\n    if (storeBuffer[i].Q === pass.name) {\r\n      storeBuffer[i].Q = ''\r\n      storeBuffer[i].V = pass.value\r\n    }\r\n  }\r\n}\r\nconst operation = (i) => {\r\n  let ret = { name: '', value: '' }\r\n  if (\r\n    instructionQueue[i].type === 'ADD.D' ||\r\n    instructionQueue[i].type === 'SUB.D'\r\n  ) {\r\n    const operation = addSubRS.find((one) => one.index === i)\r\n    ret.name = operation.name\r\n    if (operation.op === 'ADD') {\r\n      const add = operation.Vj + operation.Vk\r\n      const reg = regFile.find((one) => one.Q === operation.name)\r\n      ret.value = add\r\n      if (reg) reg.Q = add\r\n    } else {\r\n      const sub = operation.Vj - operation.Vk\r\n      const reg = regFile.find((one) => one.Q === operation.name)\r\n      ret.value = sub\r\n      if (reg) reg.Q = sub\r\n    }\r\n    addSubRS[addSubRS.indexOf(operation)] = {\r\n      name: operation.name,\r\n      op: '',\r\n      Vj: '',\r\n      Vk: '',\r\n      Qj: '',\r\n      Qk: '',\r\n      busy: 0,\r\n      index: -1,\r\n    }\r\n  }\r\n  if (\r\n    instructionQueue[i].type === 'MUL.D' ||\r\n    instructionQueue[i].type === 'DIV.D'\r\n  ) {\r\n    const operation = mulDivRS.find((one) => one.index === i)\r\n    ret.name = operation.name\r\n\r\n    if (operation.op === 'MUL') {\r\n      const mul = operation.Vj * operation.Vk\r\n      const reg = regFile.find((one) => one.Q === operation.name)\r\n      ret.value = mul\r\n      if (reg) reg.Q = mul\r\n    } else {\r\n      const div = operation.Vj / operation.Vk\r\n      const reg = regFile.find((one) => one.Q === operation.name)\r\n      ret.value = div\r\n      if (reg) reg.Q = div\r\n    }\r\n    mulDivRS[mulDivRS.indexOf(operation)] = {\r\n      name: operation.name,\r\n      op: '',\r\n      Vj: '',\r\n      Vk: '',\r\n      Qj: '',\r\n      Qk: '',\r\n      busy: 0,\r\n      index: -1,\r\n    }\r\n  }\r\n  if (instructionQueue[i].type === 'L.D') {\r\n    const operation = loadBuffer.find((one) => one.index === i)\r\n    ret.name = operation.name\r\n\r\n    const load = dataMemory[operation.address]\r\n    const reg = regFile.find((one) => one.Q === operation.name)\r\n    ret.value = load\r\n    if (reg) reg.Q = load\r\n    loadBuffer[loadBuffer.indexOf(operation)] = {\r\n      name: operation.name,\r\n      busy: 0,\r\n      address: 0,\r\n      index: -1,\r\n    }\r\n  }\r\n  if (instructionQueue[i].type === 'S.D') {\r\n    const operation = storeBuffer.find((one) => one.index === i)\r\n    dataMemory[operation.address] = operation.V\r\n    storeBuffer[storeBuffer.indexOf(operation)] = {\r\n      name: operation.name,\r\n      busy: 0,\r\n      address: 0,\r\n      V: '',\r\n      Q: '',\r\n      index: -1,\r\n    }\r\n  }\r\n  return ret\r\n}\r\nconst nextCycle = (\r\n  setInstructionQueue,\r\n  setCycle,\r\n  setDone,\r\n  setRegisterFile,\r\n  setLoadBuffer,\r\n  setStoreBuffer,\r\n  setAddSubRs,\r\n  setMulDivRs,\r\n  setWriteBuffer,\r\n  setCounter,\r\n  setDataMemory,\r\n  instructionQueue1,\r\n  cycle1,\r\n  registerFile,\r\n  loadBuffer1,\r\n  storeBuffer1,\r\n  addSubRs1,\r\n  mulDivRs1,\r\n  writeBuffer,\r\n  counter1,\r\n  dataMemory1\r\n) => {\r\n  instructionQueue = instructionQueue1\r\n  cycle = cycle1\r\n  regFile = registerFile\r\n  loadBuffer = loadBuffer1\r\n  storeBuffer = storeBuffer1\r\n  addSubRS = addSubRs1\r\n  mulDivRS = mulDivRs1\r\n  writeQueue = writeBuffer\r\n  counter = counter1\r\n  dataMemory = dataMemory1\r\n  // done excution\r\n  let passed\r\n  if (writeQueue.length > 0) {\r\n    const i = writeQueue[0]\r\n    writeQueue.shift()\r\n    instructionQueue[i].write = cycle\r\n    passed = operation(i)\r\n  }\r\n  // check start excution\r\n  for (let i = 0; i < addSubRS.length; i++) {\r\n    if (\r\n      addSubRS[i].busy === 1 &&\r\n      (addSubRS[i].Vj || addSubRS[i].Vj === 0) &&\r\n      (addSubRS[i].Vk || addSubRS[i].Vk === 0) &&\r\n      !instructionQueue[addSubRS[i].index].startExecution\r\n    ) {\r\n      instructionQueue[addSubRS[i].index].startExecution = cycle\r\n      instructionQueue[addSubRS[i].index].endExecution = cycle + addCycles - 1\r\n      break\r\n    }\r\n  }\r\n  for (let i = 0; i < mulDivRS.length; i++) {\r\n    if (\r\n      mulDivRS[i].busy === 1 &&\r\n      (mulDivRS[i].Vj || mulDivRS[i].Vj === 0) &&\r\n      (mulDivRS[i].Vk || mulDivRS[i].Vk === 0) &&\r\n      !instructionQueue[mulDivRS[i].index].startExecution\r\n    ) {\r\n      instructionQueue[mulDivRS[i].index].startExecution = cycle\r\n      if (mulDivRS[i].op === 'MUL') {\r\n        instructionQueue[mulDivRS[i].index].endExecution = cycle + mulCycles - 1\r\n      } else {\r\n        instructionQueue[mulDivRS[i].index].endExecution = cycle + divCycles - 1\r\n      }\r\n      break\r\n    }\r\n  }\r\n  for (let i = 0; i < loadBuffer.length; i++) {\r\n    if (\r\n      loadBuffer[i].busy === 1 &&\r\n      !instructionQueue[loadBuffer[i].index].startExecution\r\n    ) {\r\n      instructionQueue[loadBuffer[i].index].startExecution = cycle\r\n      instructionQueue[loadBuffer[i].index].endExecution =\r\n        cycle + loadCycles - 1\r\n      break\r\n    }\r\n  }\r\n\r\n  for (let i = 0; i < storeBuffer.length; i++) {\r\n    if (\r\n      storeBuffer[i].busy === 1 &&\r\n      !instructionQueue[storeBuffer[i].index].startExecution &&\r\n      (storeBuffer[i].V || storeBuffer[i].V === 0)\r\n    ) {\r\n      instructionQueue[storeBuffer[i].index].startExecution = cycle\r\n      instructionQueue[storeBuffer[i].index].endExecution =\r\n        cycle + storeCycles - 1\r\n      break\r\n    }\r\n  }\r\n  if (instructionQueue[counter]) {\r\n    switch (instructionQueue[counter].type) {\r\n      case 'L.D':\r\n        issueLoad()\r\n        break\r\n      case 'S.D':\r\n        issueStore()\r\n        break\r\n      case 'ADD.D':\r\n        issueAdd()\r\n        break\r\n      case 'SUB.D':\r\n        issueSub()\r\n        break\r\n      case 'MUL.D':\r\n        issueMul()\r\n        break\r\n      case 'DIV.D':\r\n        issueDiv()\r\n        break\r\n      default:\r\n        console.log('Instruction not included in tomasulo')\r\n        break\r\n    }\r\n  } else {\r\n    console.log('Instruction queue is empty')\r\n  }\r\n  // waza3 yabaaaa\r\n  if (passed) distribute(passed)\r\n  for (let i = 0; i < instructionQueue.length; i++) {\r\n    if (\r\n      instructionQueue[i].endExecution &&\r\n      instructionQueue[i].endExecution === cycle\r\n    ) {\r\n      writeQueue.push(i)\r\n    }\r\n  }\r\n  // console.log(cycle)\r\n  // console.log('IQ', instructionQueue)\r\n  // console.log('Reg', regFile)\r\n  // console.log('AddSub', addSubRS)\r\n  // console.log('MulDiv', mulDivRS)\r\n  // console.log('load', loadBuffer)\r\n  // console.log('store', storeBuffer)\r\n  // console.log('******************')\r\n  cycle++\r\n  for (let i = 0; i < instructionQueue.length; i++) {\r\n    finish = true\r\n    if (!instructionQueue[i].write) {\r\n      finish = false\r\n      break\r\n    }\r\n  }\r\n  setInstructionQueue(instructionQueue)\r\n  setLoadBuffer(loadBuffer)\r\n  setStoreBuffer(storeBuffer)\r\n  setCycle(cycle)\r\n  setMulDivRs(mulDivRS)\r\n  setAddSubRs(addSubRS)\r\n  setDone(finish)\r\n  setRegisterFile(regFile)\r\n  setCounter(counter)\r\n  setWriteBuffer(writeQueue)\r\n  setDataMemory(dataMemory)\r\n}\r\n\r\nexport default nextCycle\r\n",{"ruleId":"31","replacedBy":"32"},{"ruleId":"33","replacedBy":"34"},{"ruleId":"35","severity":1,"message":"36","line":75,"column":5,"nodeType":"37","messageId":"38","endLine":75,"endColumn":14},{"ruleId":"35","severity":1,"message":"39","line":86,"column":7,"nodeType":"37","messageId":"38","endLine":86,"endColumn":17},{"ruleId":"40","severity":1,"message":"41","line":96,"column":27,"nodeType":"42","messageId":"43","endLine":96,"endColumn":76},{"ruleId":"40","severity":1,"message":"41","line":123,"column":29,"nodeType":"42","messageId":"43","endLine":123,"endColumn":78},{"ruleId":"40","severity":1,"message":"41","line":127,"column":29,"nodeType":"42","messageId":"43","endLine":127,"endColumn":78},"no-native-reassign",["44"],"no-negated-in-lhs",["45"],"no-unused-vars","'subCycles' is assigned a value but never used.","Identifier","unusedVar","'addToQueue' is assigned a value but never used.","no-loop-func","Function declared in a loop contains unsafe references to variable(s) 'instructionQueue', 'counter'.","ArrowFunctionExpression","unsafeRefs","no-global-assign","no-unsafe-negation"]